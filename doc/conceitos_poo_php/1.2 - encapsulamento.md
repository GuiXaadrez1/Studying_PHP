# ENCAPSULAMENTO NA PROGRAMAÇÃO ORIENTADA A OBJETOS COM PHP5

O encapsulamento é um dos pilares fundamentais da Programação Orientada a Objetos (POO), ao lado de herança, abstração e polimorfismo.

Seu princípio está baseado na ocultação dos detalhes internos de um objeto, expondo apenas o que é necessário para o uso externo.

O objetivo é proteger o estado interno dos objetos (atributos) e controlar o acesso e a modificação desses dados por meio de métodos controladores, conhecidos como getters e setters.

## Definiçãp 

O Encapsulamento é o princípio da POO que estabelece que os dados (atributos) e os comportamentos (métodos) de um objeto devem ser agrupados e protegidos dentro de uma estrutura, de forma que o acesso direto aos dados seja restrito e controlado.

Em termos de ciência da computação, ele cria uma barreira semântica entre o estado interno e o ambiente externo, garantindo integridade, coerência e segurança dos objetos.

## MOTIVAÇÃO E OBJETIVOS

O encapsulamento tem as seguintes finalidades:

- Proteção dos dados internos: Evita que código externo altere valores de forma incorreta ou inconsistente.

- Controle sobre o acesso e modificação: Permite validar dados antes de alterá-los.

- Modularidade e abstração: Permite alterar a implementação interna sem afetar o restante do sistema.

- Reutilização segura: Garante que classes possam ser usadas sem conhecimento de sua estrutura interna.

## MODIFICADORES DE ACESSO

O PHP fornece três níveis de visibilidade para controlar o acesso a atributos e métodos de uma classe.

| Modificador | Acesso na Classe | Acesso nas Subclasses | Acesso Externo | Uso típico                                                      |
| ----------- | ---------------- | --------------------- | -------------- | --------------------------------------------------------------- |
| `public`    | ✅                | ✅                     | ✅              | Interface pública da classe (métodos acessíveis por todos).     |
| `protected` | ✅                | ✅                     | ❌              | Atributos/métodos acessíveis apenas internamente e por herança. |
| `private`   | ✅                | ❌                     | ❌              | Atributos/métodos restritos à classe que os define.             |

## COMPARATIVO ENTRE MODIFICADORES

| Exemplo     | Explicação                                                                                             |
| ----------- | ------------------------------------------------------------------------------------------------------ |
| `public`    | O atributo/método pode ser acessado de **qualquer lugar**, inclusive fora da classe.                   |
| `protected` | Pode ser acessado apenas **dentro da classe** e **nas subclasses**. Ideal para **herança controlada**. |
| `private`   | Pode ser acessado **somente dentro da própria classe**. Não é herdado.                                 |


## QUANDO UTILIZAR CADA TIPO DE ACESSO

| Contexto                                                                              | Modificador indicado | Justificativa                                                |
| ------------------------------------------------------------------------------------- | -------------------- | ------------------------------------------------------------ |
| Quando o atributo faz parte da **interface pública** e deve ser acessado diretamente  | `public`             | Exemplo: constantes ou métodos de serviço (`getConexao()`).  |
| Quando a propriedade deve ser **herdada e controlada**, mas não acessada externamente | `protected`          | Exemplo: atributos que subclasses precisam manipular.        |
| Quando o atributo deve ser **totalmente privado e protegido** da herança              | `private`            | Exemplo: propriedades sensíveis como senhas, tokens, chaves. |


## BENEFÍCIOS DO ENCAPSULAMENTO

- Segurança: Impede alterações diretas e incorretas nos dados internos.

- Coerência lógica: Mantém o estado do objeto consistente.

- Flexibilidade: Permite mudar a implementação interna sem alterar a interface pública.

- Facilidade de manutenção: O controle centralizado reduz efeitos colaterais.

- Validação embutida: Os setters podem garantir integridade dos dados.

## EXEMPLO BASE DE ENCAPSULAMENTO


### Sem encapsulamento, usando apenas publicamente
```php
<?php

    class ContaBancaria {
        public string $titular;
        public float $saldo;
    }

    $conta = new ContaBancaria();
    $conta->titular = "Guilherme";
    $conta->saldo = -5000; // ❌ valor inválido
?>
```

Problemas:

- O saldo pode ser alterado diretamente para valores incoerentes.

- Nenhum controle sobre o que entra ou sai da conta.

- Falta de integridade dos dados.

### Aplicando encapsulamento corretamente


```php
<?php
class ContaBancaria {
    private string $titular;
    private float $saldo;

    public function __construct(string $titular, float $saldoInicial = 0) {
        $this->titular = $titular;
        $this->saldo = $saldoInicial;
    }

    // ✅ Método de leitura controlada
    public function getSaldo(): float {
        return $this->saldo;
    }

    // ✅ Método de alteração controlada
    public function depositar(float $valor): void {
        if ($valor > 0) {
            $this->saldo += $valor;
        }
    }

    public function sacar(float $valor): bool {
        if ($valor > 0 && $valor <= $this->saldo) {
            $this->saldo -= $valor;
            return true;
        }
        return false;
    }
}
?>
```

Aqui, o encapsulamento garante que o saldo nunca se torne negativo ou seja manipulado sem lógica de negócio válida.

## Uma breve explicação de GETTERS E SETTERS (ACESSORES E MODIFICADORES)

Os getters e setters são métodos públicos que controlam o acesso a **atributos privados/protegidos.**

## Exemplo:

```php
<?php
class Usuario {
    private string $email;

    public function setEmail(string $email): void {
        if (filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this->email = $email;
        } else {
            throw new InvalidArgumentException("E-mail inválido!");
        }
    }

    // método get de email (pegar para visualizar, ler, ver o valor do atributo)
    public function getEmail(): string {
        return $this->email;
    }
}
?>
```

Uso:

```php
$user = new Usuario();
$user->setEmail("guilherme@dominio.com");
echo $user->getEmail();
```

➡️ Esse padrão garante validação, consistência e segurança ao acessar dados internos.


## EXEMPLO DE APLICAÇÃO PRÁTICA COM HERANÇA

Exemplo: Encapsulamento em uma hierarquia.

```php
<?php

    class Pessoa {
        protected string $nome;
        protected int $idade;

        public function __construct(string $nome, int $idade) {
            $this->nome = $nome;
            $this->idade = $idade;
        }

        protected function descrever(): string {
            return "{$this->nome} tem {$this->idade} anos.";
        }
    }

    class Aluno extends Pessoa {
        private string $curso;

        public function __construct(string $nome, int $idade, string $curso) {
            parent::__construct($nome, $idade);
            $this->curso = $curso;
        }

        public function apresentar(): string {
            // Pode acessar $nome e $idade porque são protected
            return $this->descrever() . " É aluno de {$this->curso}.";
        }
    }

    $aluno = new Aluno("Guilherme", 21, "ADS");
    echo $aluno->apresentar();

?>
```

## CONCLUSÃO CIENTÍFICA

O encapsulamento é o mecanismo que define a fronteira entre a interface pública e a implementação interna de uma classe.

No PHP, ele é implementado através dos modificadores de acesso (public, protected, private), que controlam o nível de visibilidade e a herança de atributos e métodos.

Sua aplicação correta garante:

- Integridade dos objetos (dados sempre consistentes).

- Segurança contra acesso indevido.

- Flexibilidade para evoluir o código sem quebrar dependências.

- Isolamento e baixo acoplamento entre componentes.

Em síntese, o encapsulamento é o que transforma dados em entidades inteligentes, conferindo comportamento, segurança e abstração — os fundamentos da verdadeira orientação a objetos.