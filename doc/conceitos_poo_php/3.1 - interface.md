# Introdu√ß√£o 
Vamos aprender um pouco sobre interfaces 

## üß© Defini√ß√£o cient√≠fica de Interface

Uma interface √© um contrato formal que define um conjunto de m√©todos que uma classe deve obrigatoriamente implementar, mas sem definir a implementa√ß√£o desses m√©todos.

üëâ Em termos cient√≠ficos, a interface atua como uma abstra√ß√£o comportamental, especificando o que uma classe deve fazer, mas n√£o como ela deve fazer.

Ela √© usada para garantir um comportamento comum entre classes diferentes, promovendo polimorfismo estrutural (todas as classes que implementam a interface podem ser tratadas de forma uniforme, mesmo que suas implementa√ß√µes sejam distintas).

## Sintaxe e estrutura b√°sica

Em PHP, criamos uma interface com a palavra-chave interface.

```php
<?php

interface Animal {
    public function fazerSom(): string;
    public function mover(): void;
}
```

- Nenhum m√©todo dentro de uma interface pode ter corpo (implementa√ß√£o);

- Todos os m√©todos s√£o implicitamente p√∫blicos (public);

- Voc√™ n√£o pode declarar propriedades com valores dentro da interface (apenas constantes).

## Implementando uma Interface

Para implementar uma interface, usa-se a palavra-chave: **"implements."**

```php
<?php

class Cachorro implements Animal {
    public function fazerSom(): string {
        return "Au Au!";
    }

    public function mover(): void {
        echo "O cachorro est√° correndo!";
    }
}

class Gato implements Animal {
    public function fazerSom(): string {
        return "Miau!";
    }

    public function mover(): void {
        echo "O gato est√° andando silenciosamente...";
    }
}
```

üîç Aqui, tanto Cachorro quanto Gato seguem o contrato definido pela interface Animal.
Mesmo que o comportamento interno seja diferente, ambas garantem que possuem os m√©todos fazerSom() e mover().

## Motiva√ß√£o e objetivo

A principal motiva√ß√£o cient√≠fica do uso de interfaces √© a programa√ß√£o orientada a abstra√ß√µes.

Isto significa que o c√≥digo deve depender de interfaces e n√£o de implementa√ß√µes concretas "Classes", o que gera baixo acoplamento e alta coes√£o.

```php
<?php

class Cachorro implements Animal {
    public function fazerSom(): string {
        return "Au Au!";
    }

    public function mover(): void {
        echo "O cachorro est√° correndo!";
    }
}

class Gato implements Animal {
    public function fazerSom(): string {
        return "Miau!";
    }

    public function mover(): void {
        echo "O gato est√° andando silenciosamente...";
    }
}

## craindo uma fun√ß√£o que rescebe
function emitirSom(Animal $animal) {
    // acessado o m√©todo fazersom da interface
    echo $animal->fazerSom();
}

$cachorro = new Cachorro();
$gato = new Gato();

emitirSom($cachorro); // Au Au!
emitirSom($gato);     // Miau!
```

Aqui, a fun√ß√£o emitirSom n√£o precisa saber se √© um Cachorro ou Gato.

Ela s√≥ exige que o objeto seja do tipo Animal (interface), ou seja, que siga o contrato.

## Interface vs Classe Abstrata

| Caracter√≠stica   | Interface                                  | Classe Abstrata                                         |
| ---------------- | ------------------------------------------ | ------------------------------------------------------- |
| Objetivo         | Define **o que** deve ser feito            | Define **o que** e **como parcialmente** deve ser feito |
| M√©todos          | Apenas assinaturas (sem corpo)             | Pode ter m√©todos concretos e abstratos                  |
| Atributos        | N√£o pode ter atributos (exceto constantes) | Pode ter atributos e constantes                         |
| Heran√ßa m√∫ltipla | Pode implementar v√°rias interfaces         | S√≥ pode herdar de uma classe abstrata                   |
| Palavra-chave    | `implements`                               | `extends`                                               |

## Implementando m√∫ltiplas interfaces
Em PHP, uma classe pode implementar v√°rias interfaces, separadas por v√≠rgulas:

```php
<?php

// criando uma interface
interface Andar {
    public function andar();
}

// criando outra interface
interface Falar {
    public function falar();
}

// criando uma fun√ß√£o que materializa multiplas interfaces
class Humano implements Andar, Falar {
    public function andar() {
        echo "O humano est√° andando.";
    }

    public function falar() {
        echo "O humano est√° falando.";
    }
}
```

‚úÖ Isso √© o que se chama de heran√ßa m√∫ltipla de comportamento, algo que n√£o √© permitido entre classes, mas √© poss√≠vel entre interfaces

## Interfaces e Polimorfismo

Interfaces refor√ßam o polimorfismo de tipo ‚Äî isto √©, v√°rias classes diferentes podem ser tratadas como o mesmo tipo, desde que implementem a mesma interface.

```php
<?php

function moverAnimal(Animal $animal) {
    $animal->mover();
}

moverAnimal(new Cachorro());
moverAnimal(new Gato());
```

## Interfaces com constantes

Interfaces tamb√©m podem conter constantes, que atuam como valores fixos para todas as classes que as implementam.

```php
<?php

// implementando uma interface
interface Logger {
    // definindo costantes na interface, isso √© v√°lido
    const LEVEL_INFO = "INFO";
    const LEVEL_ERROR = "ERROR";

    // pr√©-definindo um comportamento, a√ß√£o
    public function log(string $message, string $level): void;
}

// criando uma class que implementa essa interface
class FileLogger implements Logger {

    // criando uma fun√ß√£o sobre escreve o m√©todo pr√©-definido na  interface
    public function log(string $message, string $level): void {
        echo "[" . $level . "] " . $message;
    }
}

// materializando uma classe
$logger = new FileLogger();

// acessando a fun√ß√£o, passando uma string com par√¢metro e 
// acessando o valor da contante presente na interface com o operador de resolu√ß√£o ::
// d√™ aten√ß√£o a esse operador, pois ele √© muito importante

$logger->log("Sistema iniciado", Logger::LEVEL_INFO);
```

## Interface como contrato de integra√ß√£o (camadas)

Interfaces s√£o essenciais quando voc√™ quer definir pontos de integra√ß√£o entre m√≥dulos de um sistema.

Por exemplo:

```php

// criando interface
interface RepositorioUsuario {

    // pr√©-definido a√ß√£o que realiza busca por id
    public function buscarPorId(int $id);
    
    // pr√©-definido a√ß√£o que salva um conjunto de dados
    public function salvar(array $dados);
}

// Criando uma class que implementa a interface
class RepositorioUsuarioMySQL implements RepositorioUsuario {
    public function buscarPorId(int $id) {
        // SELECT * FROM usuarios WHERE id = ?
    }

    public function salvar(array $dados) {
        // INSERT INTO usuarios (...)
    }
}


// Criando uma class que implementa a interface
class RepositorioUsuarioMemoria implements RepositorioUsuario {
    
    // definindo um array de usu√°rios
    private $usuarios = [];

    public function buscarPorId(int $id) {
        
        // usando operador variante da tern√°rio - Null Coalesce Operator (??)
        // ele verifica se a vari√°vel definida tem valor, se n√£o tiver
        // retorna um valor padr√£o

        return $this->usuarios[$id] ?? null;
    }

    public function salvar(array $dados) {
        $this->usuarios[$dados['id']] = $dados;
    }
}
```

üî¨ Agora, o c√≥digo que depende do RepositorioUsuario n√£o precisa saber qual banco est√° sendo usado ‚Äî s√≥ precisa saber que a classe cumpre o contrato.

## Quando usar Interfaces

- Voc√™ quer definir um contrato comum entre classes diferentes;

- Deseja desacoplar m√≥dulos (ex: usar Invers√£o de Depend√™ncia);

- Precisa trocar implementa√ß√µes facilmente (ex: de um Logger para outro);

- Deseja testar com mocks/stubs, sem depender de classes concretas.

## Conclus√£o conceitual

- Interfaces promovem padroniza√ß√£o, flexibilidade e baixo acoplamento;

- Elas n√£o substituem a heran√ßa, mas a complementam, refor√ßando o polimorfismo;

- O uso correto de interfaces eleva o n√≠vel de abstra√ß√£o de um sistema, aproximando-o dos princ√≠pios SOLID, especialmente o I (Interface Segregation Principle) e o D (Dependency Inversion Principle).