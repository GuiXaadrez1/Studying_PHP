# M√©todos Getters e Setters em PHP (Abordagem Cient√≠fica e Avan√ßada)

## Conceito Fundamental

Em POO, os m√©todos getters e setters s√£o as portas de entrada e sa√≠da controladas dos atributos de uma classe.

Eles s√£o a interface p√∫blica entre o mundo externo (quem usa a classe) e o estado interno (os dados encapsulados).

üß† Defini√ß√£o formal:

Um getter √© um m√©todo p√∫blico respons√°vel por obter o valor de um atributo privado ou protegido.

Um setter √© um m√©todo p√∫blico respons√°vel por atribuir um valor controlado a um atributo privado ou protegido, garantindo valida√ß√£o, coer√™ncia e seguran√ßa de estado.

## Por que eles existem?

Sem getters e setters, qualquer parte do c√≥digo poderia modificar livremente os atributos de um objeto ‚Äî o que viola o princ√≠pio do encapsulamento e quebra a integridade do estado do objeto.

### ‚úÖ Uso Correto ‚Äî encapsulamento com controle:

```php
<?php
class Pessoa {
    private string $nome;

    public function setNome(string $nome): void {
        // regra de neg√≥cio: o nome deve ter pelo menos 3 letras
        if (strlen($nome) < 3) {
            throw new Exception("O nome deve ter pelo menos 3 caracteres.");
        }
        $this->nome = $nome;
    }

    public function getNome(): string {
        return $this->nome;
    }
}
?>
```

### ‚ùå Uso Errado ‚Äî acesso direto ao atributo:

```php
<?php
class Pessoa {
    public string $nome;
}

$p = new Pessoa();
$p->nome = ''; // sem valida√ß√£o, estado inv√°lido
?>
```

## Estrutura Can√¥nica dos M√©todos Getters e Setters

Em PHP, os padr√µes recomendados seguem a conven√ß√£o camelCase e nomes descritivos

| Tipo de M√©todo | Estrutura             | Descri√ß√£o                                                |
| -------------- | --------------------- | -------------------------------------------------------- |
| **Getter**     | `getAtributo()`       | Retorna o valor do atributo                              |
| **Setter**     | `setAtributo($valor)` | Define o valor do atributo (possivelmente com valida√ß√£o) |

### Exemplo Completo

```php
<?php

    class Pessoa {
        private string $nome;
        private int $idade;

        public function __construct(string $nome, int $idade) {
            $this->setNome($nome);
            $this->setIdade($idade);
        }

        // os m√©todos sempre s√£o criados da segiunte forma:
        // fun√ß√£o publica + assinatura da fun√ß√£o + nome get + nome atributo

        // Getter e Setter de Nome
        public function getNome(): string {
            return $this->nome;
        }

        public function setNome(string $nome): void {
            if (strlen($nome) < 3) {
                throw new Exception("O nome deve ter pelo menos 3 letras.");
            }
            $this->nome = ucfirst($nome);
        }

        // Getter e Setter de Idade
        public function getIdade(): int {
            return $this->idade;
        }

        public function setIdade(int $idade): void {
            if ($idade < 0) {
                throw new Exception("Idade inv√°lida.");
            }
            $this->idade = $idade;
        }
        }

        // Teste pr√°tico
        try {
        $pessoa = new Pessoa("carlos", 25);
        echo "Nome: " . $pessoa->getNome() . "<br>";
        echo "Idade: " . $pessoa->getIdade();
        } catch (Exception $e) {
        echo "Erro: " . $e->getMessage();
    }
?>
```

üîç An√°lise t√©cnica:

O construtor usa os setters internamente ‚Äî isso garante que todas as valida√ß√µes sejam aplicadas tamb√©m na inicializa√ß√£o.

O m√©todo getNome() √© somente leitura.

O m√©todo setNome() √© somente escrita controlada, validando antes de alterar o estado.

## Rela√ß√£o com o Encapsulamento

Os getters e setters s√£o a materializa√ß√£o pr√°tica do encapsulamento.
Eles:

- Protegem os atributos internos da classe contra modifica√ß√µes indevidas.

- Isolam regras de neg√≥cio dentro da pr√≥pria classe.

- Permitem mudan√ßas internas sem afetar quem usa a classe.

- üß† Conceito chave: O encapsulamento n√£o √© esconder dados por esconder, mas garantir consist√™ncia e seguran√ßa sem expor a estrutura interna.

## Tipos de Encapsulamento e Quando Usar Getters/Setters

| Tipo de Acesso | Palavra-chave                                  | Quando usar                             | Exemplo             |
| -------------- | ---------------------------------------------- | --------------------------------------- | ------------------- |
| `public`       | acess√≠vel de qualquer lugar                    | quando precisa ser vis√≠vel externamente | m√©todos p√∫blicos    |
| `protected`    | acess√≠vel apenas pela classe e suas subclasses | quando s√≥ herdeiros podem manipular     | m√©todos utilit√°rios |
| `private`      | acess√≠vel apenas pela classe                   | quando deve ser completamente interno   | atributos de estado |


## Encadeamento de M√©todos (Fluent Interface)

Getters e setters podem ser usados com encadeamento (method chaining), retornando $this no setter.

Isso melhora a fluidez da API da classe.

```php
<?php

    class Usuario {
        private string $email;
        private string $senha;

        public function setEmail(string $email): self {
            $this->email = $email;
            return $this; // permite encadeamento
        }

        public function setSenha(string $senha): self {
            $this->senha = password_hash($senha, PASSWORD_DEFAULT);
            return $this;
        }

        public function getEmail(): string {
            return $this->email;
        }
    }

    $u = (new Usuario())
        ->setEmail("user@email.com")
        ->setSenha("123456");

    echo $u->getEmail();
?>
```

Fluent Interface √© um padr√£o que melhora a legibilidade e expressividade do c√≥digo, muito usado em frameworks modernos (como o Eloquent do Laravel).

## Getters e Setters M√°gicos (__get e __set)

PHP possui m√©todos m√°gicos que permitem interceptar o acesso a atributos inexistentes ou inacess√≠veis (como privados), criando getters e setters din√¢micos.


```php
<?php

    class Pessoa {
        private array $dados = [];

        public function __set($nome, $valor) {
            echo "Definindo {$nome} como {$valor}<br>";
            $this->dados[$nome] = $valor;
        }

        public function __get($nome) {
            return $this->dados[$nome] ?? null;
        }
    }

    $p = new Pessoa();
    $p->nome = "Carlos";  // chama __set
    echo $p->nome;        // chama __get
?>
```

‚ö†Ô∏è Aten√ß√£o:
Esses m√©todos s√£o √∫teis para classes gen√©ricas (como entidades ORM), mas devem ser usados com parcim√¥nia, pois:

- Enfraquecem a valida√ß√£o de tipo.

- Dificultam depura√ß√£o e manuten√ß√£o.

- Quebram o contrato expl√≠cito da classe

## Boas Pr√°ticas Avan√ßadas

Valide sempre dentro do setter (n√£o no getter).

Evite expor atributos desnecess√°rios.

Prefira read-only (get sem set) para atributos que n√£o mudam ap√≥s o construtor.

Evite getters e setters autom√°ticos sem prop√≥sito ‚Äî s√≥ crie quando realmente houver l√≥gica, valida√ß√£o ou encapsulamento a proteger.

Combine com tipagem forte (PHP >=8) para garantir integridade.

## Exemplo com Regras de Neg√≥cio Reais

```php
<?php
    class ContaBancaria {
        private float $saldo = 0;

        public function depositar(float $valor): void {
            if ($valor <= 0) {
                throw new Exception("Dep√≥sito inv√°lido.");
            }
            $this->saldo += $valor;
        }

        public function sacar(float $valor): void {
            if ($valor > $this->saldo) {
                throw new Exception("Saldo insuficiente.");
            }
            $this->saldo -= $valor;
        }

        public function getSaldo(): float {
            return $this->saldo;
        }
    }

    $conta = new ContaBancaria();
    $conta->depositar(1000);
    $conta->sacar(300);

    echo "Saldo atual: R$ " . $conta->getSaldo();
?>
```

Aqui:

- saldo √© protegido do acesso direto.

- O controle de integridade √© feito pelos m√©todos p√∫blicos.

- O objeto mant√©m consist√™ncia interna, mesmo sob opera√ß√µes externa

## Conclus√£o Cient√≠fica

Os m√©todos getters e setters s√£o mecanismos de encapsulamento operacional, garantindo que o estado interno de um objeto permane√ßa v√°lido e coerente frente √†s intera√ß√µes externas.